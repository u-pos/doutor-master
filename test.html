<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>スキルチェック（ドクターモード対応）</title>
<style>
  :root{
    --bg:#0f1115; --fg:#eaeef2;
    --accent:#15d1ff; --good:#3ddc84; --great:#ffd54a; --miss:#ff5c62;
    --ring:#2a2f3a;
  }
  html,body{
    margin:0;height:100%; background:var(--bg); color:var(--fg);
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overscroll-behavior:none; touch-action:manipulation;
    -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
  }
  .wrap{ width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:10px; }
  header.title{
    width:100%; text-align:center; padding:10px 8px; font-weight:700; letter-spacing:.02em;
  }
  .board-wrap{
    position:relative; width:100%; max-width:680px; aspect-ratio:1/1;
    margin:0 auto; display:flex; align-items:center; justify-content:center;
  }
  canvas{ width:100%; height:100%; display:block; background:transparent; }
  .overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    pointer-events:none;
  }
  .ovtxt{
    text-align:center; font-weight:800; font-size:clamp(20px,6vw,40px); line-height:1.2;
    text-shadow: 0 2px 10px rgba(0,0,0,.45);
  }
  .ovtxt .small{ display:block; font-size:.6em; opacity:.9; font-weight:700; }
  .btns{
    width:min(96%,680px); display:grid; grid-template-columns:1fr 1fr; gap:10px;
  }
  button{
    background:#1a1f2b; color:var(--fg); border:1px solid #2d3442;
    border-radius:14px; padding:14px 10px; font-size:clamp(14px,4.2vw,18px);
    font-weight:700; cursor:pointer; box-shadow:0 4px 14px rgba(0,0,0,.2);
    transition:transform .05s ease, background .2s ease, border-color .2s ease;
    touch-action:manipulation;
  }
  button:active{ transform: translateY(1px) scale(0.995); }
  #startBtn{ background:#22304a; border-color:#2f4b79; }
  #doctorBtn.active{ outline:2px solid var(--accent); box-shadow:0 0 0 3px rgba(21,209,255,.15); }
  .meta{
    width:min(96%,680px); display:flex; justify-content:space-between; align-items:center;
    font-size:clamp(12px,3.8vw,16px); opacity:.9;
  }
  .pill{
    display:inline-block; padding:4px 10px; border-radius:999px; background:#1b2130; border:1px solid #2a3243; font-weight:700;
  }
  .score{ font-weight:800; }
</style>
</head>
<body>
  <div class="wrap">
    <header class="title">スキルチェック（ドクターモード対応）</header>

    <div class="meta">
      <div class="pill">ステージ <span id="stage">1</span></div>
      <div class="pill">連続成功 <span class="score" id="streak">0</span></div>
    </div>

    <div class="board-wrap" id="boardWrap">
      <canvas id="cv" width="800" height="800" aria-label="skill-check board"></canvas>
      <div class="overlay"><div class="ovtxt" id="ovtxt">目指せ50連続！<span class="small">タップ/クリックで判定</span></div></div>
    </div>

    <div class="btns">
      <button id="startBtn" type="button">スタート</button>
      <button id="doctorBtn" type="button">ドクターモード</button>
    </div>
  </div>

<script>
(() => {
  // ===== 基本参照 =====
  const wrap = document.getElementById('boardWrap');
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const ovtxt = document.getElementById('ovtxt');
  const startBtn = document.getElementById('startBtn');
  const doctorBtn = document.getElementById('doctorBtn');
  const stageEl = document.getElementById('stage');
  const streakEl = document.getElementById('streak');

  // ===== 可変ゲーム状態 =====
  let playing = false;
  let doctorMode = false;

  let cx = cv.width/2, cy = cv.height/2;  // 円の中心
  let R = 260;                             // 外周半径（針の長さもこれに合わせる）
  const ringWidth = 14;                    // リングの太さ
  const needleLen = R;                     // 針は外周まで
  let angle = -Math.PI / 2;                // 現在角（上から開始）
  let speed = 1.9;                         // 角速度（rad/sec 相当、描画でΔt掛け）
  let lastTs = 0;

  // 成功ゾーン（中央角と幅）※グッドの幅・グレイトの幅
  let zoneAngle = randRange(-Math.PI, Math.PI);
  let zoneWidthGood = deg2rad(40);
  let zoneWidthGreat = deg2rad(16);

  // 進行
  let stage = 1;
  let streak = 0;

  // ===== ユーティリティ =====
  function deg2rad(d){ return d*Math.PI/180; }
  function radNorm(r){
    // -PI～PIに正規化
    r = (r + Math.PI) % (2*Math.PI);
    if (r < 0) r += 2*Math.PI;
    return r - Math.PI;
  }
  function angleDiff(a, b){
    // 最小角差 |a-b| （-PI..PIに折りたたみ）
    return Math.abs(radNorm(a - b));
  }
  function randRange(min, max){ return min + Math.random()*(max-min); }

  // 盤面リサイズと安全半径調整
  function fitCanvas(){
    const rect = wrap.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    cv.width = Math.round(size * devicePixelRatio);
    cv.height = Math.round(size * devicePixelRatio);

    // 半径は盤サイズから少し余裕を持たせる
    const pad = 28 * devicePixelRatio; // 外周やテキスト分の安全枠
    const maxR = Math.floor(Math.min(cv.width, cv.height)/2 - pad);
    R = Math.max(80*devicePixelRatio, Math.min(300*devicePixelRatio, maxR));
  }

  // 「中心をランダム移動（安全）」：針や外周が盤外に出ない
  function relocateCenterSafely(){
    // 安全マージンは外周半径R（針長もR）＋多少の描画余白
    const M = R + ringWidth*2 + 2;
    const minX = M, maxX = cv.width - M;
    const minY = M, maxY = cv.height - M;

    // 盤面が小さい場合は中央固定
    if (minX > maxX || minY > maxY){
      cx = cv.width/2; cy = cv.height/2; return;
    }
    cx = Math.round(randRange(minX, maxX));
    cy = Math.round(randRange(minY, maxY));
  }

  // ステージ更新：成功ゾーン位置変更＆スピードわずかにUP（上がりすぎ防止）
  function nextStage(){
    stage++;
    zoneAngle = randRange(-Math.PI, Math.PI);
    // 難易度の微調整（大きく変えない）
    speed = Math.min(speed + 0.07, 3.4);
    // 稀にグレイト幅をほんの少しだけ狭める（上限）
    zoneWidthGreat = Math.max(deg2rad(10), zoneWidthGreat - deg2rad(0.2));
    stageEl.textContent = stage;

    if (doctorMode){
      relocateCenterSafely();
    }
  }

  function resetGame(){
    playing = false;
    stage = 1; streak = 0;
    speed = 1.9; angle = -Math.PI/2;
    zoneAngle = randRange(-Math.PI, Math.PI);
    zoneWidthGood = deg2rad(40);
    zoneWidthGreat = deg2rad(16);
    stageEl.textContent = stage; streakEl.textContent = streak;

    // 盤中央スタート（ドクターモードは成功時にだけ移動）
    cx = cv.width/2; cy = cv.height/2;

    ovtxt.style.color = '';
    ovtxt.innerHTML = '目指せ50連続！<span class="small">タップ/クリックで判定</span>';
    draw(0);
  }

  // ===== 入力 =====
  function onPress(){
    if (!playing){
      // 開始直後の1回目のタップは無効にせず、そのまま判定として採用
      // もし純粋に開始だけにしたい場合は、ここで return; してね。
    }
    // 判定
    const d = angleDiff(angle, zoneAngle);
    if (d <= zoneWidthGreat/2){
      // GREAT
      streak++; streakEl.textContent = streak;
      flashText('GREAT!', '#ffd54a');
      // 50以上継続での特殊メッセージ等が必要ならここで分岐
      nextStage();
    } else if (d <= zoneWidthGood/2){
      // GOOD
      streak++; streakEl.textContent = streak;
      flashText('GOOD', '#3ddc84');
      nextStage();
    } else {
      // MISS
      gameOver();
    }
  }

  function flashText(text, color){
    ovtxt.textContent = text;
    ovtxt.style.color = color;
    // 0.3秒演出
    const keep = 300;
    const now = performance.now();
    let endAt = now + keep;
    (function tempLoop(t){
      if (t < endAt){
        requestAnimationFrame(tempLoop);
      } else {
        ovtxt.textContent = '';
      }
    })(now);
  }

  function gameOver(){
    playing = false;
    ovtxt.style.color = '#ffffff';
    ovtxt.textContent = 'GAME OVER';
  }

  // ===== 描画 =====
  function draw(ts){
    // Δtで角度更新（playing時のみ）
    if (!lastTs) lastTs = ts;
    const dt = Math.min((ts - lastTs)/1000, 0.05); // 秒
    lastTs = ts;
    if (playing){
      angle += speed * dt;
      angle = radNorm(angle);
    }

    // クリア
    ctx.clearRect(0,0,cv.width,cv.height);

    // 背景の微グラデ（円周）
    const g = ctx.createRadialGradient(cx,cy, R*0.2, cx,cy, R*1.1);
    g.addColorStop(0, '#141924');
    g.addColorStop(1, '#0f141e');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(cx, cy, R + ringWidth*2.2, 0, Math.PI*2);
    ctx.fill();

    // 外周リング
    ctx.lineWidth = ringWidth;
    ctx.strokeStyle = '#263045';
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI*2);
    ctx.stroke();

    // 成功ゾーン（GOOD）
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(zoneAngle - zoneWidthGood/2);
    ctx.strokeStyle = 'rgba(61,220,132,0.9)'; // GOOD
    ctx.lineWidth = ringWidth*0.9;
    ctx.beginPath();
    ctx.arc(0, 0, R, 0, zoneWidthGood);
    ctx.stroke();
    ctx.restore();

    // 成功ゾーン（GREAT）
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(zoneAngle - zoneWidthGreat/2);
    ctx.strokeStyle = 'rgba(255,213,74,0.95)'; // GREAT
    ctx.lineWidth = ringWidth*0.7;
    ctx.beginPath();
    ctx.arc(0, 0, R, 0, zoneWidthGreat);
    ctx.stroke();
    ctx.restore();

    // 目盛り（軽く）
    ctx.strokeStyle = '#2b354c';
    ctx.lineWidth = 2 * devicePixelRatio;
    for (let i=0;i<60;i++){
      const aa = i*Math.PI*2/60;
      const sr = R - ringWidth*0.9, er = R - ringWidth*0.4;
      const sx = cx + Math.cos(aa)*sr, sy = cy + Math.sin(aa)*sr;
      const ex = cx + Math.cos(aa)*er, ey = cy + Math.sin(aa)*er;
      ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex,ey); ctx.stroke();
    }

    // 針（赤）
    const nx = cx + Math.cos(angle) * needleLen;
    const ny = cy + Math.sin(angle) * needleLen;
    ctx.strokeStyle = '#ff4b55';
    ctx.lineWidth = 6 * devicePixelRatio;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(nx, ny);
    ctx.stroke();

    // 中央キャップ
    ctx.fillStyle = '#eaeef2';
    ctx.beginPath();
    ctx.arc(cx, cy, 7*devicePixelRatio, 0, Math.PI*2);
    ctx.fill();

    requestAnimationFrame(draw);
  }

  // ===== イベント =====
  startBtn.addEventListener('click', () => {
    resetGame();
    playing = true;
    ovtxt.textContent = '';
  });

  doctorBtn.addEventListener('click', () => {
    doctorMode = !doctorMode;
    doctorBtn.classList.toggle('active', doctorMode);
    doctorBtn.textContent = doctorMode ? 'ドクターモード（ON）' : 'ドクターモード';
  });

  // タップ/クリックで判定
  cv.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    onPress();
  });

  // スペースキーでも判定
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space'){ e.preventDefault(); onPress(); }
  });

  // レイアウト変化に追従
  const ro = new ResizeObserver(() => {
    const prevR = R;
    fitCanvas();
    // Rが変わった場合、盤面の端に寄っていたら外れる危険があるので中央に戻す
    // （ドクターモードで次成功時にまたランダム移動します）
    if (Math.abs(prevR - R) > 1){
      cx = cv.width/2; cy = cv.height/2;
    }
  });
  ro.observe(wrap);

  // 初期化
  fitCanvas();
  resetGame();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
