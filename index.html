<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>DBDスキルチェック：怒涛の嵐（固定速度・赤針＋白ゾーン）</title>
<style>
  :root{ --bg:#0f1115; --fg:#eaeef2; --muted:#9aa4af; --accent:#ffffff; --danger:#ef4444; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:12px;padding:12px}
  .topbar{width:100%;max-width:720px;display:flex;justify-content:center;align-items:center}
  .btn{border:1px solid #26303a;background:#161a21;color:var(--fg);border-radius:12px;padding:10px 16px;font-weight:800;cursor:pointer;touch-action:manipulation}
  .btn.primary{background:#1f2937;border-color:#334155}
  .btn.warn{background:#3a2b12;border-color:#8a5a12;color:#fde68a}
  .btn.accent{background:#122031;border-color:#2a3f59}

  .board{width:100%;max-width:720px;aspect-ratio:1/1;position:relative}
  canvas{width:100%;height:100%;display:block;border-radius:16px;background:#0b0e13}

  .tap-row{width:100%;max-width:720px;margin-top:10px;display:flex;justify-content:center}
  #tapBtn{
    width:min(92%,560px);height:72px;border-radius:16px;border:2px solid #334155;
    background:#0f131a;color:#e5e7eb;font-weight:900;font-size:clamp(18px,5vw,28px);
    letter-spacing:1px;box-shadow:0 6px 18px rgba(0,0,0,.35); user-select:none; -webkit-tap-highlight-color:transparent;
  }
  #tapBtn[disabled]{opacity:.45;filter:saturate(.4)}

  .bottombar{margin-top:10px;width:100%;max-width:720px;display:flex;justify-content:space-between;gap:8px;position:sticky;bottom:0;padding-bottom:4px}
  .ctrls{display:flex;gap:8px;margin:0 auto}
  .hint{font-size:12px;color:var(--muted);text-align:center;margin-top:4px}

  dialog{border:none;border-radius:14px;padding:0;max-width:520px;width:90vw;background:#0f131a;color:var(--fg)}
  .dlg-head{padding:14px 16px;border-bottom:1px solid #253040;font-weight:700}
  .dlg-body{padding:12px 16px}
  .rank-list{width:100%;border-collapse:collapse}
  .rank-list th,.rank-list td{padding:8px 6px;border-bottom:1px solid #1d2533;text-align:left}
  .rank-list th{color:#aab4bf;font-weight:600}
</style>
</head>
<body>
  <div class="wrap">
    <!-- 上部はスタートだけ -->
    <div class="topbar">
      <button id="startBtn" class="btn primary">▶ スタート</button>
    </div>

    <!-- 盤面 -->
    <div class="board">
      <canvas id="cv"></canvas>
    </div>

    <!-- 円の下にTAPボタン -->
    <div class="tap-row">
      <button id="tapBtn" aria-label="Tap to check" disabled>TAP</button>
    </div>

    <!-- 下部コントロール：ミュート削除 → スタート/一時停止/ランキング -->
    <div class="bottombar">
      <div class="ctrls">
        <button id="startBtn2" class="btn primary">▶ スタート</button>
        <button id="pauseBtn" class="btn warn">⏸ 一時停止</button>
        <button id="rankBtn" class="btn accent">🏆 ランキング</button>
      </div>
    </div>

    <div class="hint">※ 成功時に <code>success.mp3</code>、失敗時に <code>bomb.mp3</code> を再生（初回操作で解放）。</div>
  </div>

  <!-- ランキング（名前なし：日付＋連続回数） -->
  <dialog id="rankDlg">
    <div class="dlg-head">🏆 オフライン TOP5</div>
    <div class="dlg-body">
      <table class="rank-list" id="rankTable">
        <thead><tr><th>#</th><th>日付</th><th>連続回数</th></tr></thead>
        <tbody></tbody>
      </table>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px">
        <button id="closeRank" class="btn">閉じる</button>
        <button id="resetRank" class="btn warn">リセット</button>
      </div>
    </div>
  </dialog>

<script>
(() => {
  // ===== 固定設定（本家寄せ・ラグ対策込み） =====
  const CONFIG = {
    zoneArcRatio: 0.16,          // ★白ゾーン幅は常に0.16
    baseRPM: 60,                 // ★一定速度（RPM）
    markerArcRatio: 0.02,        // スイープ可視用の幅
    inputCooldownMs: 45,         // 低レイテンシ・誤爆防止
    nextZoneMinDeg: 180,         // 成功後の次ゾーン中心オフセット範囲（度）
    nextZoneMaxDeg: 220
  };

  // ===== 要素 =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha: false, desynchronized: true });
  const startBtn = document.getElementById('startBtn');
  const startBtn2= document.getElementById('startBtn2');
  const pauseBtn = document.getElementById('pauseBtn');
  const rankBtn  = document.getElementById('rankBtn');
  const tapBtn   = document.getElementById('tapBtn');
  const rankDlg  = document.getElementById('rankDlg');
  const rankTbd  = document.querySelector('#rankTable tbody');
  const closeRank= document.getElementById('closeRank');
  const resetRank= document.getElementById('resetRank');

  // ===== 状態 =====
  let running=false, paused=false;
  let lastInputAt=0;
  let streak=0;

  const FULL = Math.PI*2;
  const zoneSize = FULL * CONFIG.zoneArcRatio;
  const markerSize = FULL * CONFIG.markerArcRatio;

  // 速度は不変
  const rpm = CONFIG.baseRPM;

  // スイープ角は baseAngle @ baseTime から算出
  let baseAngle=0; // rad
  let baseTime=0;  // performance.now()

  // 白ゾーンの開始角
  let zoneStart=0;

  // DPR対応
  let cssW=0, cssH=0, dpr=1;
  function resizeCanvas(){
    const rect = cv.getBoundingClientRect();
    dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
    cssW = rect.width; cssH = rect.height;
    cv.width  = Math.round(cssW * dpr);
    cv.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw(performance.now());
  }
  new ResizeObserver(resizeCanvas).observe(cv);

  // ===== オーディオ（成功/失敗・事前デコード） =====
  const successAudio = new Audio('success.mp3');
  const bombAudio    = new Audio('bomb.mp3');
  [successAudio, bombAudio].forEach(a => { a.preload='auto'; a.volume=0.9; });
  function warmAudio(a){
    a.play().then(()=>{ a.pause(); a.currentTime=0; }).catch(()=>{});
  }
  function unlockAudio(){
    warmAudio(successAudio);
    warmAudio(bombAudio);
    window.removeEventListener('pointerdown', unlockAudio, {once:true});
  }
  window.addEventListener('pointerdown', unlockAudio, {once:true});

  // ===== 角度計算 =====
  const norm = a => (a % FULL + FULL) % FULL;
  function sweepAngleAt(t){
    const rps = rpm / 60;
    const delta = (t - baseTime)/1000;
    return norm(baseAngle + rps * FULL * delta);
  }
  const inRange = (a,s,e) => (s<=e) ? (a>=s && a<=e) : (a>=s || a<=e);

  // ===== 描画（赤い固定針＋白ゾーン＋グレーの通過マーカー） =====
  function draw(now){
    const w = cssW, h = cssH;
    const CX = w/2, CY = h/2;
    const rOuter = Math.min(w,h)*0.42;
    const rInner = rOuter - 36;

    const sweepCenter = sweepAngleAt(now);

    ctx.clearRect(0,0,w,h);

    // 背景円
    ctx.beginPath(); ctx.arc(CX, CY, rOuter+24, 0, FULL);
    ctx.fillStyle = '#0a0d12'; ctx.fill();

    // ベースリング
    ctx.beginPath(); ctx.arc(CX, CY, rOuter, 0, FULL);
    ctx.lineWidth = 20; ctx.strokeStyle = '#1a2330'; ctx.stroke();

    // 白ゾーン（成功範囲）※シャドウ無しで軽量化
    ctx.beginPath(); ctx.lineWidth = 20; ctx.strokeStyle = '#ffffff';
    ctx.arc(CX, CY, rOuter, zoneStart, zoneStart+zoneSize); ctx.stroke();

    // スイープ（通過マーカー：薄いグレー）
    ctx.beginPath(); ctx.lineWidth = 20; ctx.strokeStyle = '#bfc7d1';
    ctx.arc(CX, CY, rOuter, sweepCenter - markerSize/2, sweepCenter + markerSize/2); ctx.stroke();

    // 赤い固定針（常に12時方向）
    ctx.save(); ctx.translate(CX, CY);
    ctx.rotate(-Math.PI/2); // 12時へ
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, -rInner);
    ctx.lineWidth = 6; ctx.strokeStyle = '#ef4444'; ctx.stroke();
    ctx.restore();
  }

  // ループ
  function loop(now){
    if(!running){ return; }
    if(!paused){ draw(now); }
    requestAnimationFrame(loop);
  }

  // 成功後のゾーン移動：直前成功角 + [180°,220°] に次ゾーン中心を置く
  function moveZoneAfterSuccess(successAngle){
    const min = CONFIG.nextZoneMinDeg * Math.PI / 180;
    const max = CONFIG.nextZoneMaxDeg * Math.PI / 180;
    const offset = min + Math.random()*(max - min);
    // 中心 = successAngle+offset、開始角は中心 - zoneSize/2
    zoneStart = norm(successAngle + offset - zoneSize/2);
  }

  // 開始時のランダム初期配置
  function randomizeZoneInitial(){
    zoneStart = Math.random()*FULL;
  }

  // 入力：押した瞬間の角度で即判定（低レイテンシ＆描画待ちなし）
  function onTap(){
    if(!running || paused) return;
    const now = performance.now();
    if(now - lastInputAt < CONFIG.inputCooldownMs) return;
    lastInputAt = now;

    const a = sweepAngleAt(now);
    const ok = inRange(a, zoneStart, norm(zoneStart + zoneSize));

    if(ok){
      // 内部時間の基準更新（見た目と同期）
      baseAngle = a; baseTime = now;
      try{ successAudio.currentTime=0; successAudio.play().catch(()=>{});}catch{}
      streak++;
      moveZoneAfterSuccess(a);
      // すぐ描画（体感ラグの最小化）
      draw(now);
    }else{
      gameOver();
    }
  }

  // 制御
  function startGame(){
    resizeCanvas();
    running=true; paused=false; streak=0;
    baseAngle=0; baseTime=performance.now();
    randomizeZoneInitial();
    tapBtn.disabled=false;
    requestAnimationFrame(loop);
  }
  function pauseGame(){
    if(!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? '▶ 再開' : '⏸ 一時停止';
    // 再開直後のズレ防止
    const now = performance.now();
    baseAngle = sweepAngleAt(now);
    baseTime  = now;
    draw(now);
  }
  function stopGame(){ running=false; paused=false; tapBtn.disabled=true; }

  function gameOver(){
    try{ bombAudio.currentTime=0; bombAudio.play().catch(()=>{});}catch{}
    stopGame();
    saveScore({score:streak, at:Date.now()});
    renderRanking();
  }

  // ランキング（名前なし：日付＋連続回数）
  const KEY='skillcheck_top5_fixedspeed_v2_bomb';
  function loadScores(){ try{ return JSON.parse(localStorage.getItem(KEY)||'[]'); }catch{return []} }
  function saveScore(entry){
    if(entry.score<=0) return;
    const arr = loadScores(); arr.push(entry);
    arr.sort((a,b)=> b.score - a.score || b.at - a.at);
    localStorage.setItem(KEY, JSON.stringify(arr.slice(0,5)));
  }
  function renderRanking(){
    const arr = loadScores(); rankTbd.innerHTML='';
    arr.forEach((e,i)=>{
      const dt=new Date(e.at);
      const d=`${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')} ${String(dt.getHours()).padStart(2,'0')}:${String(dt.getMinutes()).padStart(2,'0')}`;
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>${i+1}</td><td>${d}</td><td>${e.score}</td>`;
      rankTbd.appendChild(tr);
    });
  }
  function resetRanking(){ localStorage.removeItem(KEY); renderRanking(); }

  // イベント
  const startBoth = () => startGame();
  startBtn .addEventListener('click', startBoth, {passive:true});
  startBtn2.addEventListener('click', startBoth, {passive:true});
  pauseBtn .addEventListener('click', pauseGame, {passive:true});
  rankBtn  .addEventListener('click', ()=>{ renderRanking(); rankDlg.showModal(); }, {passive:true});
  closeRank.addEventListener('click', ()=>rankDlg.close(), {passive:true});
  resetRank.addEventListener('click', ()=>{ if(confirm('ランキングをリセットするで？')) resetRanking(); }, {passive:true});

  tapBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); onTap(); }, {passive:false});
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); onTap(); } });

  // 初期
  renderRanking();
  requestAnimationFrame(resizeCanvas);
})();
</script>
</body>
</html>
